name: Generate MikroTik RSC Files
on:
  workflow_dispatch:
  push:
    branches: [main]

permissions:
  contents: write

env:
  RESOURCES: openai,another_resource
  FORWARD_TO: Google
  ADDRESS_LIST: BlackList
  JSON_URL_TEMPLATE: https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/{resource}.json

jobs:
  generate-rsc:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Process each resource
        run: |
          set -e
          IFS=',' read -ra resource_array <<< "${{ env.RESOURCES }}"
          
          FORWARD_TO="${{ env.FORWARD_TO }}"
          ADDRESS_LIST="${{ env.ADDRESS_LIST }}"
          JSON_URL_TEMPLATE="${{ env.JSON_URL_TEMPLATE }}"
          
          for resource in "${resource_array[@]}"; do
            echo "Processing resource: $resource"
            json_url="${JSON_URL_TEMPLATE//\{resource\}/$resource}"
            
            mkdir -p "$resource"
            
            if ! curl -s -f "$json_url" > "input_$resource.json"; then
              echo "Failed to fetch JSON for $resource, skipping..."
              continue
            fi
            
            # Determine address list part
            if [ "$ADDRESS_LIST" = "false" ]; then
              ADDR_ARG=""
              LIST_SUFFIX="NoList"
            else
              ADDR_ARG=" address-list=$ADDRESS_LIST"
              LIST_SUFFIX="$ADDRESS_LIST"
            fi
            
            output_file="$resource/FWD_${resource}_${FORWARD_TO}_${LIST_SUFFIX}.rsc"
            # Always create the file with header (so file exists even if no entries)
            echo "/ip dns static" > "$output_file"
            
            # ---- domain (match-subdomain=no) ----
            # .rules[]? safely handles missing .rules; if domain is string -> emit it, if array -> emit each element
            domains=$(jq -r '
              .rules[]? 
              | (.domain // empty)
              | if type=="string" then . else .[] end
            ' "input_$resource.json" | sort -u)
            
            if [ -n "$domains" ]; then
              echo "$domains" | while IFS= read -r domain; do
                domain_trimmed=$(echo "$domain" | sed -e 's/^[[:space:]]*//; s/[[:space:]]*$//')
                if [ -n "$domain_trimmed" ]; then
                  echo "add$ADDR_ARG forward-to=$FORWARD_TO comment=$resource type=FWD name=$domain_trimmed" >> "$output_file"
                fi
              done
            fi

            # ---- domain_suffix (match-subdomain=yes) ----
            suffixes=$(jq -r '
              .rules[]?
              | (.domain_suffix // empty)
              | if type=="string" then . else .[] end
            ' "input_$resource.json" | sort -u)
            
            if [ -n "$suffixes" ]; then
              echo "$suffixes" | while IFS= read -r domain_suffix; do
                suf_trimmed=$(echo "$domain_suffix" | sed -e 's/^[[:space:]]*//; s/[[:space:]]*$//')
                if [ -n "$suf_trimmed" ]; then
                  echo "add$ADDR_ARG forward-to=$FORWARD_TO comment=$resource match-subdomain=yes type=FWD name=$suf_trimmed" >> "$output_file"
                fi
              done
            fi

            # ---- domain_regex (regexp entries) ----
            regex_list=$(jq -r '
              .rules[]?
              | (.domain_regex // empty)
              | if type=="string" then . else .[] end
            ' "input_$resource.json" | sort -u)
            
            if [ -n "$regex_list" ]; then
              echo "$regex_list" | while IFS= read -r regex; do
                # escape backslashes and double quotes for safe embedding in double-quoted RSC attribute
                escaped_regex=$(printf '%s' "$regex" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')
                # trim
                escaped_regex=$(echo "$escaped_regex" | sed -e 's/^[[:space:]]*//; s/[[:space:]]*$//')
                if [ -n "$escaped_regex" ]; then
                  echo "add$ADDR_ARG forward-to=$FORWARD_TO comment=$resource type=FWD regexp=\"$escaped_regex\"" >> "$output_file"
                fi
              done
            fi

            echo "Wrote $output_file"
          done

      - name: Commit and push changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add */FWD_*.rsc
          git commit -m "Update RSC files for ${{ env.RESOURCES }}"
          git push