name: Generate MikroTik RSC Files

on:
  workflow_dispatch:

permissions:
  contents: write

env:
  RESOURCES: openai,youtube,facebook,intel
  FORWARD_TO: Google
  ADDRESS_LIST: BlackList
  JSON_URL_TEMPLATE: https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/{resource}.json

jobs:
  generate-rsc:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Process and update files via API
        run: |
          set -e
          IFS=',' read -ra resource_array <<< "${{ env.RESOURCES }}"
          
          FORWARD_TO="${{ env.FORWARD_TO }}"
          ADDRESS_LIST="${{ env.ADDRESS_LIST }}"
          JSON_URL_TEMPLATE="${{ env.JSON_URL_TEMPLATE }}"
          
          for resource in "${resource_array[@]}"; do
            echo "Processing resource: $resource"
            json_url="${JSON_URL_TEMPLATE//\{resource\}/$resource}"
            
            # Скачиваем JSON
            if ! curl -s -f "$json_url" > "input_$resource.json"; then
              echo "Failed to fetch JSON for $resource, skipping..."
              continue
            fi
            
            if [ "$ADDRESS_LIST" = "false" ]; then
              ADDR_ARG=""
            else
              ADDR_ARG=" address-list=$ADDRESS_LIST"
            fi
            
            # Генерируем содержимое файла
            file_content="/ip dns static"
            
            # domain rules
            domains=$(jq -r '
              .rules[]
              | if (.domain | type == "string") then [.domain]
                elif (.domain | type == "array") then .domain
                else [] end
              | .[]' "input_$resource.json" | sort -u)
            if [ -n "$domains" ]; then
              while read -r domain; do
                file_content="${file_content}"$'\n'"add${ADDR_ARG} forward-to=$FORWARD_TO comment=$resource match-subdomain=no type=FWD name=$domain"
              done <<< "$domains"
            fi

            # domain_suffix rules
            suffixes=$(jq -r '
              .rules[]
              | if (.domain_suffix | type == "string") then [.domain_suffix]
                elif (.domain_suffix | type == "array") then .domain_suffix
                else [] end
              | .[]' "input_$resource.json" | sort -u)
            if [ -n "$suffixes" ]; then
              while read -r suffix; do
                file_content="${file_content}"$'\n'"add${ADDR_ARG} forward-to=$FORWARD_TO comment=$resource match-subdomain=yes type=FWD name=$suffix"
              done <<< "$suffixes"
            fi

            # domain_regex rules
            mapfile -t regex_array < <(jq -r '
              .rules[]
              | if (.domain_regex | type == "string") then [.domain_regex]
                elif (.domain_regex | type == "array") then .domain_regex
                else [] end
              | .[]' "input_$resource.json" | sort -u)
            for regex in "${regex_array[@]}"; do
                [ -z "$regex" ] && continue
                # Удваиваем каждый обратный слеш (из \\ делаем \\\\)
                escaped_regex=$(echo "$regex" | sed -e 's/\\\\/\\\\\\\\/g' -e 's/\\/\\\\/g')
                # Затем экранируем остальные спецсимволы
                escaped_regex=$(echo "$escaped_regex" | sed -e 's/"/\\"/g' -e 's/\$/\\\$/g' -e 's/?/\\?/g' -e 's/ /\\_/g')
                file_content="${file_content}"$'\n'"add${ADDR_ARG} forward-to=$FORWARD_TO comment=$resource type=FWD regexp=\"$escaped_regex\""
            done

            # Обновляем файл через GitHub API
            output_file="$resource/FWD_${resource}_${FORWARD_TO}_${ADDRESS_LIST}.rsc"
            
            # Получаем текущий SHA файла (если существует)
            current_sha=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/contents/$output_file" | jq -r .sha) || current_sha=""
            
            # Кодируем содержимое в base64
            encoded_content=$(echo "$file_content" | base64 -w0)
            
            # Создаем/обновляем файл через API
            api_data="{
              \"message\": \"Update $output_file\",
              \"content\": \"$encoded_content\"
            }"
            
            if [ -n "$current_sha" ] && [ "$current_sha" != "null" ]; then
              api_data=$(echo "$api_data" | jq -c ". + {\"sha\": \"$current_sha\"}")
            fi
            
            response=$(curl -s -w "%{http_code}" -X PUT \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/json" \
              "https://api.github.com/repos/${{ github.repository }}/contents/$output_file" \
              -d "$api_data")
            
            http_code=${response: -3}
            if [ "$http_code" -eq 200 ] || [ "$http_code" -eq 201 ]; then
              echo "✅ Updated $output_file via API"
            else
              echo "❌ Failed to update $output_file. HTTP code: $http_code"
              echo "Response: ${response%???}"
            fi
            
            rm -f "input_$resource.json"
          done
