name: Generate MikroTik RSC Files for scripts from iplist.opencck.org

on:
  schedule:
    - cron: "25 0 * * *"    # ежедневно в 00:25
  workflow_dispatch:

permissions:
  contents: write

env:
  GROUP: "torrent, anime"
  SITE: "rutor.info, nnmclub.to"
  GROUP_URL_TEMPLATE: https://iplist.opencck.org/?format=json&data=domains&wildcard=1&group={group}
  SITE_URL_TEMPLATE: https://iplist.opencck.org/?format=json&data=domains&wildcard=1&site={site}
  MAX_ENTRIES_PER_FILE: 150

jobs:
  generate-rsc:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Process groups and sites
        run: |
          set -e
          IFS=',' read -ra group_array <<< "${{ env.GROUP }}"
          IFS=',' read -ra site_array <<< "${{ env.SITE }}"
          GROUP_URL_TEMPLATE="${{ env.GROUP_URL_TEMPLATE }}"
          SITE_URL_TEMPLATE="${{ env.SITE_URL_TEMPLATE }}"
          MAX_ENTRIES_PER_FILE="${{ env.MAX_ENTRIES_PER_FILE }}"

          mkdir -p for_scripts

          # Process groups
          for group in "${group_array[@]}"; do
              group=$(echo "$group" | xargs)
              echo "Processing group: $group"
              json_url="${GROUP_URL_TEMPLATE//\{group\}/$group}"
              
              if ! curl -s -f "$json_url" > "input_$group.json"; then
                  echo "Failed to fetch JSON for group $group, skipping..."
                  continue
              fi

              # Get resource names (keys) from JSON
              resources=$(jq -r 'keys[]' "input_$group.json" | sort -u)

              # Process each resource in the group
              while IFS= read -r resource; do
                  # Extract base resource name without TLD
                  base_resource=$(echo "$resource" | sed -E 's/\.[a-zA-Z]+$//')
                  echo "Processing resource: $base_resource (from $resource)"
                  
                  # Get domains for the resource (all treated as suffixes with match-subdomain=yes)
                  suffixes=$(jq -r --arg resource "$resource" '.[$resource][]' "input_$group.json" | sort -u | grep -v '^$' || true)

                  # Combine suffixes into entries, only if non-empty
                  all_entries=()
                  if [ -n "$suffixes" ]; then
                      while IFS= read -r suffix; do
                          all_entries+=("suffix:$suffix")
                      done <<< "$suffixes"
                  fi

                  # Skip if no valid entries
                  entry_count=${#all_entries[@]}
                  if [ $entry_count -eq 0 ]; then
                      echo "No valid entries for $base_resource, skipping..."
                      continue
                  fi

                  # Check if entries fit in one file
                  if [ $entry_count -le $MAX_ENTRIES_PER_FILE ]; then
                      output_file="for_scripts/${base_resource}.rsc"
                      echo ":global AddressList" > "$output_file"
                      echo ":global ForwardTo" >> "$output_file"
                      echo "/ip dns static" >> "$output_file"
                      for entry in "${all_entries[@]}"; do
                          type=$(echo "$entry" | cut -d':' -f1)
                          value=$(echo "$entry" | cut -d':' -f2-)
                          if [ "$type" = "suffix" ]; then
                              echo ":if ([:len [/ip dns static find name=\"$value\"]] = 0) do={ add address-list=\$AddressList forward-to=\$ForwardTo comment=\"$base_resource\" match-subdomain=yes type=FWD name=\"$value\" }" >> "$output_file"
                          fi
                      done
                  else
                      # Split into multiple files
                      part=1
                      entry_index=0
                      while [ $entry_index -lt $entry_count ]; do
                          output_file="for_scripts/${base_resource}_part${part}.rsc"
                          echo ":global AddressList" > "$output_file"
                          echo ":global ForwardTo" >> "$output_file"
                          echo "/ip dns static" >> "$output_file"
                          for ((i=0; i<MAX_ENTRIES_PER_FILE && entry_index<entry_count; i++, entry_index++)); do
                              entry=${all_entries[$entry_index]}
                              type=$(echo "$entry" | cut -d':' -f1)
                              value=$(echo "$entry" | cut -d':' -f2-)
                              if [ "$type" = "suffix" ]; then
                                  echo ":if ([:len [/ip dns static find name=\"$value\"]] = 0) do={ add address-list=\$AddressList forward-to=\$ForwardTo comment=\"$base_resource\" match-subdomain=yes type=FWD name=\"$value\" }" >> "$output_file"
                              fi
                          done
                          part=$((part + 1))
                      done
                  fi
              done <<< "$resources"
          done

          # Process individual sites
          for site in "${site_array[@]}"; do
              site=$(echo "$site" | xargs)
              echo "Processing site: $site"
              json_url="${SITE_URL_TEMPLATE//\{site\}/$site}"
              
              if ! curl -s -f "$json_url" > "input_$site.json"; then
                  echo "Failed to fetch JSON for site $site, skipping..."
                  continue
              fi

              # Extract base resource name without TLD
              base_resource=$(echo "$site" | sed -E 's/\.[a-zA-Z]+$//')
              echo "Processing resource: $base_resource (from $site)"

              # Get domains for the site (all treated as suffixes with match-subdomain=yes)
              suffixes=$(jq -r --arg site "$site" '.[$site][]' "input_$site.json" | sort -u | grep -v '^$' || true)

              # Combine suffixes into entries, only if non-empty
              all_entries=()
              if [ -n "$suffixes" ]; then
                  while IFS= read -r suffix; do
                      all_entries+=("suffix:$suffix")
                  done <<< "$suffixes"
              fi

              # Skip if no valid entries
              entry_count=${#all_entries[@]}
              if [ $entry_count -eq 0 ]; then
                  echo "No valid entries for $base_resource, skipping..."
                  continue
              fi

              # Check if entries fit in one file
              if [ $entry_count -le $MAX_ENTRIES_PER_FILE ]; then
                  output_file="for_scripts/${base_resource}.rsc"
                  echo ":global AddressList" > "$output_file"
                  echo ":global ForwardTo" >> "$output_file"
                  echo "/ip dns static" >> "$output_file"
                  for entry in "${all_entries[@]}"; do
                      type=$(echo "$entry" | cut -d':' -f1)
                      value=$(echo "$entry" | cut -d':' -f2-)
                      if [ "$type" = "suffix" ]; then
                          echo ":if ([:len [/ip dns static find name=\"$value\"]] = 0) do={ add address-list=\$AddressList forward-to=\$ForwardTo comment=\"$base_resource\" match-subdomain=yes type=FWD name=\"$value\" }" >> "$output_file"
                      fi
                  done
              else
                  # Split into multiple files
                  part=1
                  entry_index=0
                  while [ $entry_index -lt $entry_count ]; do
                      output_file="for_scripts/${base_resource}_part${part}.rsc"
                      echo ":global AddressList" > "$output_file"
                      echo ":global ForwardTo" >> "$output_file"
                      echo "/ip dns static" >> "$output_file"
                      for ((i=0; i<MAX_ENTRIES_PER_FILE && entry_index<entry_count; i++, entry_index++)); do
                          entry=${all_entries[$entry_index]}
                          type=$(echo "$entry" | cut -d':' -f1)
                          value=$(echo "$entry" | cut -d':' -f2-)
                          if [ "$type" = "suffix" ]; then
                              echo ":if ([:len [/ip dns static find name=\"$value\"]] = 0) do={ add address-list=\$AddressList forward-to=\$ForwardTo comment=\"$base_resource\" match-subdomain=yes type=FWD name=\"$value\" }" >> "$output_file"
                          fi
                      done
                      part=$((part + 1))
                  done
              fi
          done

      - name: Commit and push changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add for_scripts/*.rsc
          git commit -m "Update RSC files for groups ${{ env.GROUP }} and sites ${{ env.SITE }}" || exit 0
          git push